The bear wandered through the forest.
A wolf howled at the moon.
The dog barked loudly.
The cat climbed up high.
An apple fell from the tree.
A pear rolled away.
A strawberry grew sweet.
His headphones were lost.
Her wallet was found.
The dog's head was low.
The tree swayed gently.

# Billion users

We have all these meme coins and more casino type applications popping out and we don't need to be as highbrow and and say that they don't matter, they don't count or they're or look at them from above and, you know, be highbrow and we should accept that if we want to bring a new users those users will behave differently. Maybe we already got 95% of the earlier adopters and the earlier daughters are willing to pick some technological or um newex risk UX uh problems with yeah problems make some concessions um but the the rest of the market, the new wave of users will not want and will not need and will not do that and we shouldn't try to force them in. so if we want more users we should give them in kinds if they want, we should give them more casino like experiences if they want and to be honest, they' kind of fun if you try that, you're gonna cl up if you realize they're fucking. and um, if we're not using either they don'tline anymore. However, was probably right. because uh now we' start to see more and more temporary wallets in the browser or the application, which is kind of. as you can set up the hot wallet use it, like deposit unit and then withdraw and that's it. In don needs a lot of trust because you're not going to have a lot of funds that application, but it's it's good enough for where the user base is good enough for you and you can probably yeah, you can set up a different type of access access if you want to, but you don't have to and you shouldn't have to.

### Llama
We have meme coins and casino-type applications emerging. We shouldn't dismiss them as unimportant; rather, let's accept their value in bringing new users on board. Those users will behave differently than earlier adopters. Maybe we've already captured 95% of early enthusiasts, who are willing to tolerate some technological risks for the sake of innovation. However, the rest of the market won't demand or need such concessions. If we want more users, we should adapt our approach and provide experiences that cater to their preferences... even if it means offering casino-like features. In fact, these types of experiences can be enjoyable. Nevertheless, some users will still choose not to engage with them.

Temporary wallets in browsers or applications are gaining traction. These allow for a simple, hot wallet setup – deposit funds, use the wallet, and then withdraw. This doesn't require extensive trust, as you're only holding small amounts within the application. For now, this solution is good enough for its intended user base.
### Chatty o1-preview
We have all these meme coins and casino-type applications popping up, and we don’t need to be highbrow and say that they don’t matter or don’t count, or look down on them. We should accept that if we want to bring in new users, those users will behave differently. Maybe we’ve already got 95% of the early adopters, and these early adopters are willing to accept some technological or new UX risks, make some concessions. But the rest of the market—the new wave of users—will not want, need, or do that, and we shouldn’t try to force them in.

So if we want more users, we should give them what they want. We should offer them more casino-like experiences if they desire, and to be honest, they’re kind of fun. If you try them, you’re going to realize they’re really fun. And if we’re not using either, they don’t align anymore. However, someone was probably right because now we start to see more and more temporary wallets in the browser or the application. You can set up the hot wallet, use it to deposit, then withdraw, and that’s it.

  

It doesn’t need a lot of trust because you’re not going to have a lot of funds in that application, but it’s good enough for your user base. You can set up a different type of access if you want to, but you don’t have to, and you shouldn’t have to.


 So today I want to talk to you about trust in decentralized AI systems.  We kind of all know, understand, we're starting to understand AI.  We understand maybe a bit more, especially this crowd.  We understand blockchain a lot more.  But there is a connection between the two, and there is a connection that makes sense.  Let's first talk about, okay, what I start with.  Who here uses AI in any kind of form?  Like chatgpt, Gemini, Cloud, the kind of, I'm looking for the kind of interface that  gives you a chat, looks like a chat, you talk to it, it writes something back to you,  or you just speak to your model and it says things back to you.  We just kind of also still like chat, but you know, text form or audio.  Out of this, like, okay, cool.  Now who is using AI differently?  Like on an API level, where you have to specify your input, your prompt, but also  the model that you want to use and other kinds of parameters, like temperature, top  K, top N, and other things like that.  Good, okay, so like, we're not going to go into the parameters, we're going to keep  it pretty high level.  But when you do that API request, you're paying for that single API request.  And you're expecting a specific model to be executed on your behalf.  You want the result back.  And this is because the actual computation of running the model locally on your machine  is expensive and your user might be running this on a laptop, on a mobile phone, or  even on a PC, but they want to use a very compute heavy model.  So that means you have to do this somewhere else, not on the machine that you're using.  So that's why we use APIs, right?  That's why we do all of this.  So now when you make that request, you're paying for it, and you expect that model  without prompt, with those specific parameters, to be used, and you want the output back.  How do you know if all of this is used correctly?  If all of the things that you input are the things that you actually are used?  And please shout it out to me, how do you know?  They tell you, that's how you know.  They tell you, you get their message back saying, we used the model that you requested,  and you kind of have to trust us.  So you usually trust the system that you're talking to.  You trust OpenAI, you trust Google, you trust whoever is running that model for you.  Let me give you a clear example.  So we have this, let me give you a clear example.  There's this company called OpenRouter, and their purpose of being is to route requests for you.  They want to become the single place where you make API requests in an API manner,  and you tell them, I want this request to be done with Claude,  or I want this request to be done with this open source model like Llama or DeepSea.  They send that to the right provider, they get the response from the provider,  and they route it back to you.  And you say, thank you.  And you also paid for that request.  Cool.  What happens now?  How do you know?  But the thing is, there is no way to know that the model they ran for you is the one that you requested.  You kind of have to trust them.  And it's not just that you have to trust them, you have to trust the runners of the model.  So that means you're not just trusting them, but they are trusting the people who run the models for them.  And the thing is, it's very, very difficult to know if someone did that computation for you correctly.  In a way, kind of that's why Bitcoin exists.  It's very difficult to send something to an external system  and hope that they're doing the correct computation for you.  You're moving a specific amount of Bitcoin from my account to other people's account,  and then you're handling that database correctly.  In Bitcoin, it's a bit easier to prove correct computation because you own an account,  you create a cryptographic proof, you sign a message, and it's easy to verify that someone signed that.  And it's very, very difficult to forge that cryptographic signature.  And that's great.  With AI, there is no cryptographic signature that we generate.  We just make an API request.  This API request is valuable enough that we have to pay for each specific API request.  Even if it's a fraction of a cent, it's still a fraction of a cent.  It's not close to zero.  And we also need some kind of assurance that that computation was correct  because I'm paying for it, and why not?  So now, when people think of cryptographic proofs for something,  you have the classical proof, which is digital signature.  It's the same kind of proof when you're signing a document or signing a transaction that you sent to Bitcoin,  but you don't have this kind of thing correctly. So whenever we want to do something like a more general proof,  the kind of go-to technology is ZK proof.  You have this kind of general computation of something or a different computation of something.  It's a bit more flexible than a simple message, which is very strict in nature.  And ZKs are usually used for computation.  It's a bit more of a...  You prove a circuit.  You prove the correct computation of something.  The thing is, to generate a proof for ZK, it's very expensive.  First, you have to take that program that you have to prove and turn it into a circuit.  Turning it into a circuit makes it a lot more complex and a lot more difficult to work with  because you have to generate a path for each...  You have to generate a proof for each path of computation,  whether the program will take that or not.  If you have an if condition, you have to compute for both paths.  But in practice, when you're running this, you're not going both paths.  You're only going one path because you're only going one path.  That means that everything...  The execution explodes in complexity.  Insert meme for explosion.  The next path is...  Let me give you some concrete numbers of what this means.  Let's assume that generating a single sentence...  You're talking to an AI and it outputs a single sentence for you.  That sentence takes maybe about two, three seconds to generate.  To generate the circuit for a single sentence takes about 10 minutes.  It's not just about the time, but the complexity of calculation you need to do  because that is expensive.  Those 10 minutes...  During those 10 minutes, you cannot do other computations.  You have to work on the proof.  During those 10 minutes, you're using a lot more energy.  Your hardware is being used to generate the proof.  So you're not generating more money.  You're still working on the initial...  On the same API request that you're trying to get the money...  Trying to be paid for.  So ZK, even though it's good in some cases, it's not good for AI.  And this is because AI is extremely...  The computation for AI is extremely expensive.  It's extremely expensive to begin with.  So what else?  You have things like social consensus.  So social consensus means that you ask multiple people to do something  and then you take the results of their work and you compare them.  If the results match, you can trust them.  If the results don't match, well, that's where things become more complicated.  And they become more complicated because you don't know exactly who to trust.  You look at two different results and you don't know who's the right person.  So what do you do then?  You ask more people, more than two people,  and then you kind of try to use the majority.  And you still have a few edge cases.  Like let's say that all the results differ,  so you don't really know exactly who is in the wrong.  You have other problems like maybe some are working together.  Maybe all of them are using the quantized model and none of them is correct.  They're all cheating.  And a way to do this is to add some kind of smart contract in the middle  and the smart contract will do the computation for you.  And because you trust the smart contract and you trust Ethereum, Solana,  whatever network is running this for you, you trust the code.  The code was written correctly.  There is no bugs.  You can do it.  But then we still have the problem of the initial computation.  The whole AI computation is very expensive  and smart contracts are already expensive to begin with.  So this doesn't work.  So I was presenting all these problems because where I want to get to is  a solution to all of this.  There are ways to verify AI computation on chain,  and we're going to discuss this together.  So let's dig a bit into the details  and understand how inference works.  So inference takes the input, takes the whole prompt,  and generates an output for you.  The output it generates is a single token.  So that means that  you take my name is and you let it generate one word  and that word can be Claude.  And then you take all of that with Claude  and then you route it back in and you generate a new word  and you do this over and over and over again  until you finish the actual  output.  What actually happens in practice  What actually happens in practice is the  the model tells you when to stop.  They send you like an end token, an end word,  and then you know, oh, this is all done.  So  dude, lady.  Oh my god, what's with all the stupid ladies today?  So if we were to encode this as a chain of operations,  we would get something like this.  It's just like a chain of operation.  The output of one becomes the input of the other  and you just chain them together.  And after a while, you're done.  But the thing is you have this long chain,  long sequence of operations and you can't really do any kind of,  you can't do much parallelization.  So let's look at this like that.  What you can do is you can take this chain  and create a miracle tree out of it.  We've seen, and yeah, you take all this chain and you create a proof out of it.  This proof is specifically a miracle tree.  So you take all of this, you hash the adjacent operations together,  you get a node and you do this over and over again until you're left with a single root,  a single op, a single result.  That single result becomes the proof for all of your chain,  for this whole sequence of operations.  We've seen this in practice a lot with airdrops.  So for example, you put this single result in the smart contract  and then you give people the proof.  The smart contract can verify the proof  and can give people some tokens.  So like that means like, you know.  Okay, insert miracle tree that explains how miracle trees work for airdrops.  In our case, we're doing something different.  We're traversing the chain from the root to the leaves.  So we're gonna ask multiple people to do the same operation.  So we're still kind of have a social consensus,  but there's one way to prove correct execution.  We ask multiple people to build this miracle tree  from the whole sequence of operations they're generating.  And then if the roots are the same,  we pretty much know that they're correct.  But if the roots differ, we can identify what the problem is.  So in order to identify the root, the problem is we start traversing the chain.  We look at the root, we see it's different,  and we ask the nodes to give us the children of this node.  We get a result and then we keep traversing the chain  following the node that differs.  So we keep following this until we find the leaf, the left, the leftmost leaf.  Oh, the leftmost leaf.  And we just, and then like  we take this operation and we give it to the smart contract.  It's gonna be like a single operation, a single  proof they have to verify.  And it's not gonna be the whole set of operations.  As I said, we trust the chain and then we'll see who did the operation correctly  and who made the mistake.  Who made the mistake or who tried to cheat.  There's no big difference between the two.  So what do you do after?  You still have like a staking, you punish them.  But it gets a bit more complicated to what I was trying to explain today.  What's going on, boys?  It's not gonna work, right? 

